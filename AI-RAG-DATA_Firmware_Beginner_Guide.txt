
I would say try to get a feel for everything. Being able to use hardware abstractions layers (HALs) and libraries, open source or vendor provided, IS A SKILL regardless of what anyone says. Using HALs and libraries shows that you can take someone elses code understand it and apply it for whatever your application is. This is very much common practice in industry and more often than not you will be using stuff that already exists instead of rolling your own because time to market matters and figuring out a new chip and writing everything from the ground up is very time consuming. Of course the HAL route will not always work and the provided HAL may not implement some feature that is needed, for example vendor library implements i2c driver that is blocking and causes the cpu to wait while the transfer is in progress but for your application it must do non blocking using an interrupt so you will need to implement your own driver for that, this is very common as most HALs feel like glorified tech demos written by some clueless intern trying to rush it before summer is over and signed off by an even more clueless manager rather than something usable in production *cough cough* NXP. That being said you should understand bare metal as well, being able to write your own device drivers and poking at registers is important. Over my years I met a ton of clowns... errr engineers that have no idea what a register is let alone how to use pointers to read/write to a memory address because all they do is use HALs or use the classic write(), read(), modify() functions someone else made in the company that abstract away the usage of pointers to registers and memory locations. Bare metal also lets you get balls deep in vendor chip manuals and register datasheets which is also a skill. From a pure personal perspective when I work on projects at home I always go extreme bare metal: No HALs, no libraries and stdlib, custom linker script, custom core bootloader/startup (if possible). All in all everything has its place.

Yes C is the most popular and aint going away anytime soon, if you know what a pointer is and how to use it I dont doubt your ability. Python + bash/shell/powershell for scripting are your friends as well and in some extremely rare circumstances you may come across and use TCL. There is also the emergence of Rust in the embedded space, but it won't be used in an established company anytime soon, but you can always learn the basics and have it in your arsenal if your interested.

This depends entirely on who is interviewing you and what they value. Personally from my perspective, projects showcase your abilities, style and approach to problems. Ehh... anyone who calls themselves an expert in C unironically is a clown, as long as you know pointers and basic bit manipulation you good, anything else you can pick up on the job. Bare metal and datasheets kinda go hand in hand, they both rely on each other. So if your project has bare metal it shows you can go through the vendor datasheet imo but ymmv depending whose on the other end. But this really depends on the interviewer, sometimes you land an interviewer that is chill and cares more about your character and whether or not you give off positive energy and are fun to be around with some sprinkled easy technical questions like "what is a fifo" or "what are the two signals on the i2c bus called" and sometimes you will get the guy who wants to know if you can code some bullshit algorithm that they themselves barely knows or not at all.

There is no magic formula, just need to pick up a board and get to learning. Focus on stuff that interests you personally and the stars will align.

Closing advice: Just like people come in all shapes and sizes, each engineer has their own skill set, some are incredible programmers, but dont know a lick about hardware, some are a hybrid an have an understanding of both, and some can barely do software, but have an incredible understanding of hardware. Each one of them is valuable at the end of the day in their own regard and covers the others weaknesses.

Embedded software development has enormous depth and breadth. There are numerous vendors of microcontrollers (MCUs) with different architectures from the venerable Intel 8051 family to Microchip’s PIC family to numerous vendors with their own ARM and RISC-V based products, and all the associated IDEs, programming and debugging tools. Each MCU has its own peripherals for A to D and D to A, UART, SPI, I2C, CAN, Ethernet, DMA, timers, memory management, GPIO, etc. And then there are various problem domains including communications and networking, power electronics, control, AI, graphics, etc. with all the relevant algorithms, libraries and frameworks that go with them. And then there’s Bare Metal vs roll-your-own RTOS, versus commercial or freeware RTOSes including ThreadX, FreeRTOS, NutX, etc. and how to debug applications on these.

In reality it’s IMPOSSIBLE to master them all. A good embedded engineer knows the fundamental concepts and how to uncover and apply the information found in vendor-supplied documentation, data sheets and application notes. They also know how to clearly document their requirements, designs and their source code, especially when it is leveraging low-level peripheral functions, and can communicate this to other engineers including those responsible for test case automation and execution.
Mastery of embedded software development is a journey not a destination. You will ALWAYS be learning and growing.

The problem I see is that most students and Computer Science degrees are nowadays focused on areas such as mobile applications, databases and web application design, and less on the fundamentals of computers at the low levels that would be more applicable to an embedded software engineering role. Instead of learning C and rolling their own code, they are using Python and relying on pre-built modules and packages that do a lot of the heavy lifting. To get off to the best start in embedded you need to be doing Computer Engineering or similar and select courses that have an embedded aspect to them. Unfortunately everyone is so fixated on becoming a FAANG employee and earning a bazillion dollars in Silicon Valley that they completely overlook the opportunity to go down a different path in the embedded world, which for me at least has been a far more satisfying career path.

Look at the term "Embedded Systems".
It's a system, mechanical + electrical + software. The more you know about each part, the further you can go. You do not need to have a PhD in all, just a good understanding in most.
If you are tasked with doing a motor controller, you may ask, what is the load required. OK, you would need to know about, well, motors. Being a software guy, you would not have never taken a class on motors or not have any idea how to rate a transistor for a 2 HP motor.
Having a good understanding of the different components involved, you would be invaluable to other members on the team.
This is why you should build something for yourself. You would have to go through data sheets and learn how to code for those parts.
An employer will ask if you can write a driver for some new chip. If you can not explain how to do that, why would they hire you ?
Yes, your a beginner, but there are others that have been doing projects since they were 12 years old. How would you compete with them ??
Good Luck, Have Fun, Learn Something NEW


Well, it's been two years since I have been learning and diving into the world of embedded electronics. The first thing you need to have is the right attitude and hunger for knowledge. I am currently pursuing B.Tech, in computer science and engineering. The world of "WIRES" BREADBOARD, CHIPSETS have always fascinated me.
For starters: Get your toolkit, not an expensive one. But it should contain all the right equipment. E.g soldering iron, testers, wires!, breadboard! etc.How to start? The answer is simple: Explore! After the second year we have to make a project in any of the domains, be it software or hardware. I chose the later, because I thought it would be a great opportunity to really make a worthy project which is just not an another textbook stuff, but will be having practical implementations too.
You can think about the real world problems you face while dealing with your devices. For instance, I chose an open power monitor and tried to make it cheaper! And for about 2000/- bucks I made a simple power monitor which tracks the users' energy needs on the go.What not to expect: I have interacted with some of the people who are in this industry. First of all this is a hands-on game; theory will help you, but practicality of the hardware system is a different case altogether.
Journals: Journals like EFY or magazines do help a lot. You can also get ample amount of help from some of the Facebook/Google Group related to the same.DIY: In short, do it yourself!
Career: I am no braniac when it comes to what industry really wants as I am currently exploring my taste in the field of embedded electronics, but this picture really sums it up:
